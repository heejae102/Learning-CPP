#include<iostream>
using namespace std; 

int main()
{
	// const 포인터형 
	// 보통 함수의 파라미터로 넘길 때 사용 

	//1. 데이터와 포인터가 모두 const형인 경우 

	//데이터를 const형으로 선언한 경우, 해당 데이터를 참조하기 위한
	//포인터형도 const형으로 선언되어야 함.
	//const 포인터형으로 참조하는 데이터의 주소 값을 가져오거나,  
	//참조하여 밸류값을 가져오는 일련의 과정은 모두 가능 O
	//단, const형으로 선언된 만큼 포인터를 통해 역참조하여 밸류를 수정할 수 X

	//const int value = 5;
	//const int *ptr = &value;
	//*ptr = 6; //(X)


	//2. 데이터는 const형이 아니지만, 데이터를 참조하는 포인터가 const형인 경우

	//포인터가 const형이므로 포인터를 통해 역참조로 값을 수정하는 것은 불가능 
	//하지만 데이터는 const형이 아니므로 데이터 변수를 통해 값을 수정하는 것은 가능

	int value = 5;
	const int *ptr = &value;

	//*ptr = 6; //(X)
	value = 6;

	//cout << *ptr << endl; //수정된 값 6으로 출력 


	// ※ 주의할 점

	//const형으로 포인터 선언 시, const 데이터형의 해당 데이터 값은 수정 불가능
	//하지만 참조하는 주소 값을 바꾸는 것은 가능하다!!

	int var = 10;
	ptr = &var;
	//*ptr = 15; //참조하는 주소는 수정가능하지만 참조값은 수정 불가능 

	cout << *ptr << endl; 


	//3. 포인터 자체를 상수(const)로 만드는 경우 

	//const가 데이터형 앞에 붙어있는 경우와 달리, 
	//포인터를 통해 참조하는 값을 역참조하여 값을 수정하는 것은 가능 
	//단, 처음에 포인터에 부여된 주소값 외에 다른 주소값을 집어넣는 것은 불가능 
	//포인터 자체가 상수형이므로 선언과 동시에 초기화해주어야 함. 

	int num = 100;
	int *const p = &num;

	*p = 200;
	cout << *p << endl; 

	//p = &value; //(X)


	//4. 포인터형 자체도 const, 데이터를 참조하는 방식도 const인 경우 
	
	//포인터에 처음 부여된 주소 외에 다른 주소 값으로 수정하는 것 불가능 
	//포인터를 통해 값을 역참조해서 수정하는 것도 불가능
	//포인터 자체가 상수형이므로 선언과 동시에 초기화해주어야 함. 

	const int *const pt = &num;

	//*num = 10; //(X)
	//pt = &value; //(X)

	return 0;
}