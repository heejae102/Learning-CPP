#include<iostream>
using namespace std; 

int main()
{
	// 동적 할당 배열 
	// 정적 할당 배열은 컴파일 시에 배열의 사이즈가 결정되어 있어야 했던 반면
	// 동적 할당 배열은 런타임 시에 배열의 사이즈를 결정할 수 있어 유동적 
	// 동적으로 하당한 배열도 정적 배열과 마찬가지로 포인터 연산 및 인덱싱 가능 

	//정적 배열 선언 시 사이즈는 const로 값을 고정했어야 함. 
	//const int length = 5;
	//int array[length];

	
	//동적 배열 선언 시 런타임에 결정되는 변수 값을 사이즈에 넣는 것이 가능
	int length;
	cin >> length;

	//동적 배열 선언 시 (){} 초기화를 통해 배열의 전체 원소를 0으로 초기화 가능 
	//혹은 {1,2,3}와 같이 유니폼 초기화로 원하는 수만큼 원소값 초기화 가능 
	//원소 값을 입력하여 초기화하는 경우 ()는 사용 불가능 
	//단, 유니폼 초기화로 원소값을 입력 시 최소한 해당 원소 사이즈 이상의 
	//사이즈로 데이터를 할당받아야 오류가 발생하지 않는다. 
	int *array = new int[length] {1, 2, 3};

	array[0] = 1;
	array[1] = 2;

	for (int i = 0; i < length; i++)
	{
		cout << (uintptr_t)&array[i] << endl; 
		cout << array[i] << endl; 
	}

	delete[] array;


	//★정적 배열과 차이점★

	//1.선언 
	//정적 배열은 컴파일 타임에 결정되므로 원소가 주어져있다면 사이즈를 기입하지
	//않았어도 문제가 없지만 동적 배열은 반드시 사이즈가 주어져야 함. 

	//int fixedArray[] = { 1,2,3,4,5 };

	//int *ptr = new int[] {1, 2, 3, 4, 5};	//(X)
	int *ptr = new int[5] {1, 2, 3, 4, 5};	//(O)

	//2.리사이징(resizing)
	//정적 배열은 리사이징이 불가능 

	//동적 배열에서 리사이징 시 직접적으로는 불가능
	//추가적으로 필요한 메모리 크기만큼 더 큰 메모리를 할당받은 후 
	//기존에 가지고 있던 원소의 값들을 복사해서 해당 메모리에 넘기고
	//추가한 메모리 크기만큼 원소 값들을 추가하는 방식으로 진행

	return 0; 
}