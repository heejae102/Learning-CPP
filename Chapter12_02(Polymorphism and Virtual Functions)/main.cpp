#include<iostream>
using namespace std; 

/*

<다형성과 가상함수> 

※ 가상함수 사용 시 주의할 점 

virtual 키워드를 사용하여 구현된 함수의 호출 방식은 
일반적인 함수가 호출될 때처럼 스택이 쌓이면서 작동하는 방식이 아니다. 

virtual 테이블을 찾아서 해당 함수를 찾아가는 방식으로 호출한다. 
따라서 일반적인 방식에 비해 속도가 느리므로, 호출이 빈번하게 일어나는
함수를 virtual로 정의할 경우 퍼포먼스가 떨어진다. 

특히 게임엔진, 실시간 챗봇 등 퍼포먼스가 중요한 프로그램 환경에서는
virtual 키워드를 사용하는 데 주의를 기울일 필요가 있다. 

*/

class A
{
public:
	// virtual 키워드를 사용하여 멤버 정의 시,
	// 상속의 구조에서 포인터 및 래퍼런스의 타입을 기준으로
	// 멤버를 호출하지 않고, 실제로 가리키는 객체의 타입을 기준으로 함수 호출 
	 virtual void print() { cout << "A" << endl; }
};

class B : public A
{
public:
	virtual void print() { cout << "B" << endl; }
};

class C : public B
{
public:
	// 클래스 C는 클래스 A를 직접 상속하지 않고, 
	// 클래스 B의 멤버 print는 가상 함수가 아니지만, 
	// 가장 상위 클래스인 A 클래스에서 가상함수로 정의했을 경우,
	// A 클래스 타입으로 C 클래스를 참조하여 print 함수를 호출해도 C클래스의 함수 호출 
	virtual void print() { cout << "C" << endl; }
};

class D : public C
{
public:
	// 상속의 구조에서 오버라이딩 시, 가장 상위 클래스를 기준으로 
	// 리턴 타입이 달라져서는 안된다. 
	//int print() { cout << "D" << endl; }
	virtual void print() { cout << "D" << endl; }
};

int main()
{
	A a; 
	B b;
	C c;
	D d; 

	// A 클래스 타입으로 다른 하위 클래스의 타입을 
	// 래퍼런스로 받아 참조하려고 해도 A타입을 참조 

	// 상위 객체의 멤버를 virtual로 바꾸면 포인터 및 래퍼런스의 타입 형이 아닌
	// 실제로 가리키는 객체의 타입을 기준으로 멤버 호출 

	A &ref1 = b;
	ref1.print();

	A &ref2 = c;
	ref2.print();

	A &ref3 = d;
	ref3.print();

	//====================================================================//

	// B 클래스의 print는 가상 함수가 아님에도, B클래스 타입으로 
	// C 객체를 래퍼런스로 받아서 print 함수 호출 시 
	// 가상 함수처럼 C 객체 내의 print함수를 호출 

	// 즉, 상속의 구조에서 가장 상위 클래스(A)의 멤버를 virual로 선언하면, 
	// 나머지 하위 클래스들의 멤버도 다 virtual처럼 작동한다. 

	// 따라서 상위 클래스의 멤버를 virtual로 정의할 경우,
	// 하위 클래스들의 멤버도 virtual 키워드를 사용하는 경우도 많다. 
	// 하위 클래스에서 virtual 키워드를 사용하지 않아도 문법적인 문제는 전혀 없지만, 
	// 디버깅할 때나 클래스의 구조를 파악할 때 가상 함수로 오버라이딩 되었다는 것을
	// 확인하는 것이 큰 도움이 되기 때문 

	B &ref = c;
	ref.print();

	return 0;
}