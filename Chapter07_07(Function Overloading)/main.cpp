#include<iostream>
using namespace std; 

/*

<함수 오버로딩>

같은 이름의 함수를 매개변수의 타입이나 개수를 달리하여
같은 이름으로 함수로 사용할 수 있다. 

컴파일러는 함수에 넘겨지는 매개변수 값을 확인하여  
해당 매개변수의 타입에 맞는 적절한 함수를 호출한다. 

함수 오버로딩 시 서로 호환이 되는 자료형이나, 
매칭이 애매한 자료형을 사용할 때 유의해야 한다.
내가 의도하지 않은 방식으로 함수가 작동할 수 있다.

함수를 사용하고자 할 때 오버로딩된 함수 중 매치되는 쪽이 없는 경우,
함수를 사용하고자 할 때 오버로딩된 함수 2개 이상에서 매치되는 경우 모두 오류 발생 

※ 사용자 정의형 자료형과 오리지널 자료형은 
같은 자료형으로 인식되므로 오버로딩할 수 없다.

*/

//int형 자료형과 오버로딩되지 X 
typedef int my_int;

//void print(int x);
//void print(my_int x);

int add(int x, int y)
{
	return x + y;
}

double add(double x, double y)
{
	return x + y;
}

void print(unsigned int value) {}
void print(float value) {}

int main()
{
	//함수 오버로딩 시 주의사항 
	//오버로딩 시에 어떠한 함수를 사용할지는 컴파일 시에 결정.
	//매개변수가 같으면서 리턴 타입이 다른 것으로는 오버로딩이 되지 않는다.
	//리턴 타입만으로 어떤 함수를 호출해야 할지 결정할 수 없기 때문. 

	cout << add(1, 2) << endl;
	cout << add(3.0, 5.5) << endl;

	//-----------------------------------------------------------------//

	//오버로딩된 함수 양쪽 다 호환이 되므로 어느 쪽으로 함수를 호출해야 할지
	//애매해서 ambiguity 오류가 발생한다. 이런 경우 사용하고자 하는 함수에 맞춰
	//데이터 형태를 명확하게 해줄 필요가 있다. 
	//print('a');
	//print(0);
	//print(3.141592);

	print(unsigned int('a'));
	print(0u);					//u를 붙이면 unsigned로 캐스팅 
	print(3.141592f);			//f를 붙이면 float으로 캐스팅

	return 0;
}