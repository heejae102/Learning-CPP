#include<iostream>
#include<memory>
using namespace std; 

/*

<예외처리의 위험성과 단점>

1. 예외 처리를 하다보면 메모리 처리가 제대로 되지 않아 메모리 누수 현상이 발생할 수 있다.
-> 스마트 포인터를 사용하면 메모리가 자동으로 해제되므로 대부분의 문제 해결 가능 

2. 소멸자 내에서는 예외 처리를 할 수 없다. 

3. 예외 처리를 하는데도 비용이 소모되므로, 빈번하게 사용되는 함수나 
반복적으로 돌아가는 루프 등에서 사용할 경우 퍼포먼스가 떨어질 수 있다. 

4. 모든 오류를 예외 처리로 잡으려고 하지 않는 것이 좋다. 
일반적으로 예측가능한 범위의 오류는 if문 등을 사용하여 미연에 방지하고, 
예측범위를 벗어나는 경우에 대해서 예외 처리를 사용하는 것이 바람직. 

*/

class A
{
public:
	~A()
	{
		//throw "error";	// 소멸자 내에서는 throw 불가능 
	}
};

int main()
{
	try
	{
		int *i = new int[1000000];
		unique_ptr<int> up_i(i);

		// do something with i
		// 예외가 발생하면 delete[] 으로 메모리를 해제하지 않고 바로 catch 구문으로 이동
		// 하지만 catch 구문에서는 i에 대해 접근 할 방법이 없으므로, 
		// i의 메모리를 해제할 수 없기 때문에 메모리 누수가 발생할 수 있다. 
		
		// -> 메모리를 자동으로 해제 해주는 스마트 포인터를 사용해서 문제 해결 가능 
		// 영역을 벗어나거나 throw 될 때 유니크 포인터가 알아서 처리 해줌.
		throw "error";

		delete[] i;	// 스마트 포인터를 사용하면 해당 구문이 필요 없음. 

		//A a; 
	}
	catch (...)
	{
		cout << "catch" << endl; 
	}

	return 0;
}