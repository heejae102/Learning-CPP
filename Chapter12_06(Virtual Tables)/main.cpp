#include<iostream>
using namespace std;

/*

<가상 (함수)표 >

다형성을 사용할 때는 상속 구조에 따라서 가상 함수들이 어떻게 호출될 지 결정
이 때 가상함수에 대한 표를 만들고 사용하는데, 이를 가상표라고 부른다. 

컴파일러 내부적으로 가상 함수가 선언되면 정적 바인딩시키지 않고
가상 함수표를 만들어서 동적바인딩 시킨다. (함수 포인터를 거치는 구조라고 생각할 수 있음.)

가상 함수를 선언 할 경우, 가상 함수표와 해당 함수표에 대한 포인터가 생성된다고 할 수 있음. 
부모 클래스에 가상 함수가 있다면, 자식 클래스에도 마찬가지로 가상 함수표와 이에 대한 포인터가 존재. 

//==========================================================================================//

클래스 내 가상 함수를 호출하는 경우에는 정적 바인딩으로 호출하는 구조가 아니고,
일단 가상 함수 테이블을 찾은 뒤, 호출하고자 하는 함수와 같은 타입의 함수 포인터를 찾아서 
해당 포인터를 통해 함수를 호출하는 동적 바인딩 구조이다. 

자식 클래스의 경우 마찬가지로 함수 호출 시, 함수표에 대한 포인터를 거쳐서 가상 함수 테이블로 간 뒤 
호출하고자 하는 함수와 같은 타입의 함수 포인터를 찾아서 해당 함수를 호출 
(자식 클래스에서 오버라이드 된 함수는 해당 포인터가 있기 때문에 자식 클래스의 함수를 호출하고,
그렇지 않은 함수는 부모 클래스의 함수를 가리키기 때문에, 부모 포인터에 저장된 자식 클래스라도 
가상 함수로 선언 시 자기 자신의 함수를 호출할 수 있다.)

*/

class Base
{
public:
	// FunctionPointer *_vptr;
	virtual void func1() {};
	virtual void func2() {};
};

class Der : public Base
{
public:
	// FunctionPointer *_vptr;
	virtual void func1() {};
	void func3() {};
};

int main()
{
	return 0;
}

